<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>üîÆüê∂ AI Dog Breed Classifier</title>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        /* Custom CSS variables and base styles */
        :root {
            --bg: #f3f4f6;
            --card-bg: #ffffff;
            --accent-primary: #4f46e5; /* indigo-600 */
            --accent-secondary: #8b5cf6; /* violet-500 */
            --text-color: #1f2937;
            --border-color: #e5e7eb;
            --radius-md: 0.5rem;
            --radius-lg: 0.75rem;
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif;
        }

        body {
            min-height: 100vh;
            background-color: var(--bg);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Align content to the top */
            padding: 0.5rem; /* Minimal padding for more screen space */
            overflow-x: hidden; /* Prevent horizontal scroll due to sidebar */
            touch-action: pan-y; /* Allow vertical pan, but prevent browser zoom/pan on X axis for body */
        }

        .main-container {
            width: 100%;
            max-width: 960px; /* Increased max-width for the overall app container */
            display: flex;
            flex-direction: column; /* Default to column for mobile */
            align-items: center;
            flex-grow: 1; /* Allow container to grow */
            background-color: var(--card-bg);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-lg);
            padding: 1rem;
            position: relative; /* For sidebar positioning */
        }

        /* Mode Toggle */
        .toggle-bar {
            display: flex;
            width: 100%;
            border-radius: var(--radius-lg);
            overflow: hidden;
            margin-bottom: 1rem;
            background-color: var(--border-color);
        }

        .toggle-btn {
            flex: 1;
            padding: 0.75rem 1rem;
            border: none;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            color: var(--text-color);
            background: transparent;
            text-align: center;
        }

        .toggle-btn.active {
            background-color: var(--accent-primary);
            color: white;
            box-shadow: var(--shadow-md);
        }

        /* Webcam & Upload Areas */
        #uploadArea, #webcamArea {
            width: 100%;
            min-height: 200px;
            max-height: 50vh;
            display: none; /* Controlled by JS */
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .upload-area {
            border: 2px dashed var(--border-color);
            border-radius: var(--radius-lg);
            padding: 2rem 1rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            color: #6b7280; /* gray-500 */
        }

        .upload-area:hover {
            border-color: var(--accent-primary);
            background-color: rgba(79, 70, 229, 0.05);
        }

        .upload-area.dragover {
            background-color: rgba(79, 70, 229, 0.15);
            border-color: var(--accent-primary);
        }

        #fileInput {
            display: none;
        }

        /* Video Container */
        .video-container {
            width: 100%;
            height: 70vh; /* Takes up a significant portion of the viewport height */
            position: relative;
            overflow: hidden;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-md);
            background-color: #000;
            display: flex; /* For centering content */
            align-items: center;
            justify-content: center;
            margin-bottom: 1rem;
            touch-action: pinch-zoom; /* Allow pinch zoom only on video container */
        }

        video {
            display: block;
            width: 100%;
            height: 100%;
            object-fit: cover; /* Fill the container, might crop */
            transform-origin: center center;
            transition: transform 0.05s ease-out;
        }

        #imagePreview {
            width: 100%;
            height: 100%; /* Fill the video container */
            object-fit: contain; /* Show entire image */
            border-radius: var(--radius-lg);
            background-color: #000;
            display: none; /* Controlled by JS */
        }

        /* Overlay Buttons */
        .button-overlay {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.4);
            color: white;
            border: none;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 10;
            transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .button-overlay:hover {
            background-color: rgba(0, 0, 0, 0.6);
            transform: translateY(-2px);
        }

        #cameraToggleButton {
            top: 0.75rem;
            right: 0.75rem;
            width: 2.5rem;
            height: 2.5rem;
            font-size: 1.25rem;
        }

        #takePhotoButton {
            bottom: 0.75rem;
            left: 50%;
            transform: translateX(-50%);
            width: 4rem;
            height: 4rem;
            font-size: 1.5rem;
            background-color: rgba(79, 70, 229, 0.6); /* Indigo */
        }

        #takePhotoButton.stop-continuous {
            background-color: rgba(220, 38, 38, 0.6); /* Red */
        }

        /* Zoom Slider */
        .zoom-controls {
            width: 100%;
            margin-bottom: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 0.5rem;
            background: var(--border-color);
            border-radius: 0.5rem;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 1.25rem;
            height: 1.25rem;
            border-radius: 50%;
            background: var(--accent-primary);
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
        }

        /* Loading & Messages */
        #loading {
            display: none;
            text-align: center;
            margin: 1rem 0;
            color: var(--text-color);
        }

        .spinner {
            width: 24px;
            height: 24px;
            border: 3px solid rgba(0, 0, 0, .2);
            border-top-color: var(--accent-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 8px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        #messageBox {
            padding: 0.75rem;
            border-radius: var(--radius-md);
            text-align: center;
            font-weight: 600;
            display: none;
            width: 100%;
            margin-top: 1rem;
        }

        #messageBox.error {
            background-color: #fee2e2; /* red-100 */
            color: #dc2626; /* red-600 */
            border: 1px solid #ef4444; /* red-500 */
        }

        #messageBox.success {
            background-color: #dcfce7; /* green-100 */
            color: #16a34a; /* green-600 */
            border: 1px solid #22c55e; /* green-500 */
        }

        #messageBox.info {
            background-color: #e0f2fe; /* blue-100 */
            color: #2563eb; /* blue-600 */
            border: 1px solid #3b82f6; /* blue-500 */
        }

        /* Predictions Sidebar */
        #predictionsSidebar {
            position: fixed;
            top: 0;
            right: -300px; /* Hidden off-screen initially */
            width: 300px; /* Standard sidebar width */
            height: 100vh;
            background: rgba(255, 255, 255, 0.85); /* Partially transparent white */
            backdrop-filter: blur(8px);
            box-shadow: -4px 0 10px rgba(0, 0, 0, 0.2);
            transition: right 0.3s ease-in-out;
            z-index: 100; /* High z-index to overlay content */
            display: flex;
            flex-direction: column;
            padding: 1rem;
            color: var(--text-color);
        }

        #predictionsSidebar.open {
            right: 0; /* Slides into view */
        }

        .predictions-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .predictions-header h3 {
            font-size: 1.25rem;
            font-weight: 700;
        }

        .predictions-header button {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--accent-primary);
            padding: 0.25rem;
            border-radius: 50%;
            transition: background-color 0.2s;
        }

        .predictions-header button:hover {
            background-color: var(--border-color);
        }

        .predictions-content {
            flex-grow: 1;
            overflow-y: auto; /* Enable scrolling if many predictions */
        }

        .prediction-item {
            display: flex;
            flex-direction: column;
            background-color: #f9fafb; /* light gray */
            margin-bottom: 0.5rem;
            padding: 0.75rem 1rem;
            border-radius: var(--radius-md);
            border: 1px solid var(--border-color);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }

        .prediction-item span:first-child {
            font-weight: 600;
            margin-bottom: 0.25rem;
            color: var(--accent-primary);
        }

        .prediction-details {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
        }

        .confidence-bar {
            flex-grow: 1;
            height: 0.6rem;
            background: var(--border-color);
            border-radius: 0.3rem;
            overflow: hidden;
            margin-left: 0.5rem; /* Space between percentage and bar */
        }

        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
            transition: width .4s ease-out;
        }

        /* Mini Predictions Button (when sidebar is closed) */
        .mini-predictions-container {
            position: fixed;
            bottom: 2.5rem;
            right: 1rem;
            background-color: rgba(255, 255, 255, 0.85); /* Glassmorphism effect */
            backdrop-filter: blur(8px);
            border-radius: 9999px; /* Pill shape */
            padding: 0.5rem 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            box-shadow: var(--shadow-md);
            z-index: 90; /* Below main sidebar, above other content */
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
            cursor: pointer;
        }

        .mini-predictions-container.hidden {
            opacity: 0;
            pointer-events: none; /* Make it unclickable when hidden */
            transform: translateY(20px); /* Slide down when hidden */
        }

        .mini-predictions-container #openPredictionsButton {
            background-color: var(--accent-primary);
            color: white;
            border-radius: 50%;
            width: 2.2rem; /* Slightly smaller button */
            height: 2.2rem;
            font-size: 1rem;
            transition: background-color 0.2s;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }
        .mini-predictions-container #openPredictionsButton:hover {
            background-color: var(--accent-secondary);
        }

        /* Live Prediction Display (New element for continuous mode) */
        #livePredictionDisplay {
            min-height: 48px; /* Fixed height to prevent layout shifts */
            display: flex;
            align-items: center;
            justify-content: center;
            transition: opacity 0.3s ease-in-out;
            text-align: center;
            padding: 0.5rem 1rem;
            border-radius: var(--radius-md);
            background-color: #e0f2fe; /* blue-100 */
            color: #2563eb; /* blue-600 */
            font-weight: 600;
            width: 100%; /* Take full width */
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            margin-bottom: 1rem; /* Spacing below it */
        }


        /* Desktop Layout - Side-by-side */
        @media (min-width: 768px) {
            .main-container {
                flex-direction: row; /* Side-by-side for desktop */
                justify-content: space-between;
                align-items: flex-start; /* Align to top */
                padding: 1.5rem;
            }

            .main-content {
                flex: 1; /* Takes up available space */
                max-width: calc(100% - 300px - 1.5rem); /* Account for sidebar width + gap */
                margin-right: 1.5rem; /* Gap between main content and sidebar */
            }

            .video-container {
                height: 50vh; /* Adjust height for desktop */
                aspect-ratio: 16 / 9; /* Maintain aspect ratio */
                max-width: 100%; /* Ensure it doesn't overflow */
            }

            #predictionsSidebar {
                position: static; /* No longer fixed */
                width: 300px; /* Fixed width sidebar */
                height: auto; /* Height adapts to content */
                min-height: 400px; /* Minimum height for consistency */
                box-shadow: none; /* Remove shadow to blend with main container */
                border-left: 1px solid var(--border-color); /* Separator line */
                border-radius: 0; /* No radius on left edge */
                right: auto; /* Reset right position */
                transition: none; /* No transition for static position */
                background: var(--card-bg); /* Use solid background for desktop */
                backdrop-filter: none;
            }

            #predictionsSidebar .predictions-header button {
                display: none; /* Hide close button on desktop */
            }
            .mini-predictions-container {
                display: none !important; /* Always hide mini predictions on desktop */
            }
            #initialMessage {
                display: none; /* Hide initial message on desktop when not needed */
            }
            #livePredictionDisplay {
                display: none !important;
            }
        }
    </style>
</head>

<body>
    <div class="main-container">
        <!-- Main Content Area -->
        <div class="main-content flex flex-col items-center w-full">
            <h3 class="font-extrabold mb-2 text-center text-gray-800">üîÆüê∂ AI Dog Breed Classifier</h3>
            <p id="initialMessage" class="text-xs text-gray-600 mb-4 text-center">Choose an input source below to get started!</p>
            <div id="livePredictionDisplay" class="hidden">
                <!-- Live prediction will appear here -->
            </div>

            <!-- Mode toggle -->
            <div class="toggle-bar mb-6">
                <button id="uploadToggle" class="toggle-btn active">üìÅ Upload</button>
                <button id="webcamToggle" class="toggle-btn">üì∏ Webcam</button>
            </div>

            <!-- Upload panel -->
            <div id="uploadArea" class="upload-area w-full mb-6">
                Drop an image here or click to browse
                <input type="file" id="fileInput" accept="image/*" />
            </div>

            <!-- Uploaded Image Preview (shown only in Upload mode when an image is loaded) -->
            <div id="uploadedImagePreviewContainer" class="hidden w-full h-48 overflow-hidden rounded-lg mb-6 bg-gray-100 flex items-center justify-center p-2 border border-gray-200">
                <img id="uploadedImageDisplay" class="max-w-full max-h-full object-contain" alt="Uploaded Image Preview" />
            </div>

            <!-- Webcam panel (initially hidden) -->
            <div id="webcamArea" class="w-full">
                <div id="videoContainer" class="video-container">
                    <video id="cameraFeed" autoplay playsinline></video>
                    <img id="imagePreview" alt="Captured Frame" style="display:none;" />
                    <p id="noCameraMessage" class="absolute text-white text-center p-4 hidden bg-black bg-opacity-70 rounded-md">
                        Camera not available or access denied. Please allow camera permissions.
                    </p>
                    <button id="cameraToggleButton" class="button-overlay hidden">
                        <i class="fas fa-sync-alt"></i> <!-- Icon for camera switch -->
                    </button>
                    <button id="takePhotoButton" class="button-overlay">
                        <i class="fas fa-play"></i> <!-- Play icon initially -->
                    </button>
                </div>

                <!-- Zoom Slider (only shown in webcam mode) -->
                <div id="zoomControls" class="zoom-controls hidden mt-4">
                    <label for="zoomSlider" class="text-lg font-medium mb-2 text-gray-700">Zoom Level: <span id="zoomValue">1.0</span>x</label>
                    <input type="range" id="zoomSlider" min="1.0" max="4.0" value="1.0" step="0.1">
                </div>
            </div>

            <div id="loading" class="hidden flex flex-col items-center mt-4">
                <div class="spinner"></div>
                <p class="text-gray-700 text-sm">Processing...</p>
            </div>

            <div id="messageBox" class="message-box hidden"></div>
        </div>

        <!-- Predictions Sidebar -->
        <div id="predictionsSidebar" class="predictions-sidebar">
            <div class="predictions-header">
                <h3>Top Predictions</h3>
                <button id="closePredictions">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div id="predictionsContent" class="predictions-content">
                <!-- Prediction items will be dynamically inserted here -->
            </div>
        </div>

        <!-- Mini Predictions Button (when sidebar is closed on mobile) -->
        <div id="miniPredictions" class="mini-predictions-container hidden">
            <span id="miniPredictionText" class="text-sm font-semibold text-gray-700"></span>
            <button id="openPredictionsButton">
                <i class="fas fa-chart-bar"></i>
            </button>
        </div>
    </div>

    <script>
        const MODEL_CONFIG = {"classes": ["Affenpinscher", "Afghan Hound", "African Hunting Dog", "Airedale", "American Staffordshire Terrier", "Appenzeller", "Australian Terrier", "Basenji", "Basset", "Beagle", "Bedlington Terrier", "Bernese Mountain Dog", "Black and Tan Coonhound", "Blenheim Spaniel", "Bloodhound", "Bluetick", "Border Collie", "Border Terrier", "Borzoi", "Boston Bull", "Bouvier des Flandres", "Boxer", "Brabancon Griffon", "Briard", "Brittany Spaniel", "Bull Mastiff", "Cairn", "Cardigan", "Chesapeake Bay Retriever", "Chihuahua", "Chow", "Clumber", "Cocker Spaniel", "Collie", "Curly Coated Retriever", "Dandie Dinmont", "Dhole", "Dingo", "Doberman", "English Foxhound", "English Setter", "English Springer", "EntleBucher", "Eskimo Dog", "Flat Coated Retriever", "French Bulldog", "German Shepherd", "German Short-Haired Pointer", "Giant Schnauzer", "Golden Retriever", "Gordon Setter", "Great Dane", "Great Pyrenees", "Greater Swiss Mountain Dog", "Groenendael", "Ibizan Hound", "Irish Setter", "Irish Terrier", "Irish Water Spaniel", "Irish Wolfhound", "Italian Greyhound", "Japanese Spaniel", "Keeshond", "Kelpie", "Kerry Blue Terrier", "Komondor", "Kuvasz", "Labrador Retriever", "Lakeland Terrier", "Leonberg", "Lhasa", "Malamute", "Malinois", "Maltese", "Mexican Hairless", "Miniature Pinscher", "Miniature Poodle", "Miniature Schnauzer", "Newfoundland", "Norfolk Terrier", "Norwegian Elkhound", "Norwich Terrier", "Old English Ssheepdog", "Otterhound", "Papillon", "Pekinese", "Pembroke", "Pomeranian", "Pug", "Redbone", "Rhodesian Ridgeback", "Rottweiler", "Saint Bernard", "Saluki", "Samoyed", "Schipperke", "Scotch Terrier", "Scottish Deerhound", "Sealyham Terrier", "Shetland Sheepdog", "Shih-Tzu", "Siberian Husky", "Silky Terrier", "Soft-Coated Wheaten Terrier", "Staffordshire Bullterrier", "Standard Poodle", "Standard Schnauzer", "Sussex Spaniel", "Tibetan Mastiff", "Tibetan Terrier", "Toy Poodle", "Toy Terrier", "Vizsla", "Walker Hound", "Weimaraner", "Welsh Springer Spaniel", "West Highland White Terrier", "Whippet", "Wire-Haired Fox Terrier", "Yorkshire Terrier"], "num_classes": 120, "img_size": 224, "input_mean": [0.485, 0.456, 0.406], "input_std": [0.229, 0.224, 0.225], "best_val_accuracy": 69.89795918367346, "model_name": "mobilenet_classifier"};
        const MODEL_INPUT_NAME = 'input';
        let session = null;
        let webcamStream = null;
        let liveInterval = null; // Interval for continuous prediction
        let continuousPredictionActive = false; // Flag for continuous prediction state
        let isSidebarManuallyClosed = false; // New: Tracks if user explicitly closed sidebar

        const $ = id => document.getElementById(id);

        // UI Element References
        const cameraFeed = $('cameraFeed');
        const imagePreview = $('imagePreview'); // Used for captured webcam frames
        const uploadedImageDisplay = $('uploadedImageDisplay'); // Used for uploaded image preview
        const uploadedImagePreviewContainer = $('uploadedImagePreviewContainer'); // Container for uploaded image
        const zoomSlider = $('zoomSlider');
        const zoomValueSpan = $('zoomValue');
        const noCameraMessage = $('noCameraMessage');
        const messageBox = $('messageBox');
        const videoContainer = $('videoContainer');
        const cameraToggleButton = $('cameraToggleButton');
        const takePhotoButton = $('takePhotoButton'); // Renamed from startStopButton
        const uploadToggle = $('uploadToggle');
        const webcamToggle = $('webcamToggle');
        const uploadArea = $('uploadArea');
        const webcamArea = $('webcamArea');
        const fileInput = $('fileInput');
        const loadingSpinner = $('loading');
        const predictionsSidebar = $('predictionsSidebar');
        const predictionsContent = $('predictionsContent');
        const closePredictionsButton = $('closePredictions');
        const zoomControls = $('zoomControls');
        const miniPredictions = $('miniPredictions'); // New: Mini predictions container
        const miniPredictionText = $('miniPredictionText'); // New: Text for mini predictions
        const openPredictionsButton = $('openPredictionsButton'); // New: Button to open sidebar from mini view
        const initialMessage = $('initialMessage'); // Reference to the initial message paragraph
        const livePredictionDisplay = $('livePredictionDisplay'); // New: Live prediction display element


        let currentZoom = 1.0;
        const MIN_ZOOM = 1.0;
        const MAX_ZOOM = 4.0;
        let isFrontCamera = false; // Tracks current camera facing mode

        // For pinch-to-zoom
        let initialPinchDistance = -1;
        let lastZoom = MIN_ZOOM;

        /* --- Helpers --- */
        function isMobileDevice() {
            return (
                /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                (navigator.maxTouchPoints > 0 && navigator.userAgent.includes("Mobi"))
            );
        }

        function showMessage(message, type = 'info') {
            messageBox.textContent = message;
            messageBox.className = `message-box ${type}`;
            messageBox.style.display = 'block';
            setTimeout(() => messageBox.style.display = 'none', 4000);
        }

        function applyZoom(zoomLevel) {
            currentZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoomLevel));
            cameraFeed.style.transform = `scale(${currentZoom})`;
            zoomSlider.value = currentZoom.toFixed(1);
            zoomValueSpan.textContent = currentZoom.toFixed(1);
        }

        function showPredictionsSidebar(force = false) { // Added force flag
            if (!isSidebarManuallyClosed || force) { // Only open if not manually closed OR forced (e.g., new prediction)
                predictionsSidebar.classList.add('open');
                miniPredictions.classList.add('hidden'); // Hide mini button when sidebar is open
            }
            updateClosedSidebarDisplay(); // Always update to ensure correct state
        }

        function hidePredictionsSidebar() {
            predictionsSidebar.classList.remove('open');
            isSidebarManuallyClosed = true; // Mark as manually closed
            updateClosedSidebarDisplay(); // Show the mini display
        }

        // Updates the visibility and content of the mini prediction button and live prediction display
        function updateClosedSidebarDisplay() {
            // Only show mini-predictions if sidebar is closed AND there are actual predictions to display
            // AND only on mobile
            if (!predictionsSidebar.classList.contains('open') && predictionsContent.children.length > 0 && isMobileDevice()) {
                miniPredictions.classList.remove('hidden');
                livePredictionDisplay.classList.add('hidden');
            } else {
                miniPredictions.classList.add('hidden');
                livePredictionDisplay.classList.remove('hidden');
            }

            // Manage livePredictionDisplay visibility based on continuous mode and sidebar state
            if (continuousPredictionActive && !predictionsSidebar.classList.contains('open') && isMobileDevice()) { // Only show on mobile
                livePredictionDisplay.classList.remove('hidden');
                initialMessage.classList.add('hidden'); // Hide initial message
            } else {
                livePredictionDisplay.classList.add('hidden');
                // Show initial message only if no live prediction is active AND (not on mobile OR camera is stopped/not started)
                if (!continuousPredictionActive && (!webcamStream || !predictionsContent.children.length || !isMobileDevice())) {
                    initialMessage.classList.remove('hidden');
                } else if (isMobileDevice() && webcamStream && !continuousPredictionActive) {
                    // if webcam is showing static image (i.e. not continuous prediction), hide initial message
                    initialMessage.classList.add('hidden');
                } else {
                    initialMessage.classList.add('hidden'); // Default to hidden if live display is shown or not applicable
                }
            }
        }

        /* --- Model & Prediction --- */
        async function initModel() {
            try {
                session = await ort.InferenceSession.create('./mobilenet_classifier.onnx', {
                    executionProviders: ['wasm']
                });
                showMessage('Model ready üöÄ', 'success');
            } catch (e) {
                showMessage('Model error: ' + e.message, 'error');
            }
        }

        function preprocess(src) {
            const { input_mean, input_std, img_size } = MODEL_CONFIG;
            const cvs = document.createElement('canvas');
            cvs.width = cvs.height = img_size;
            const ctx = cvs.getContext('2d');
            ctx.drawImage(src, 0, 0, img_size, img_size);
            const d = ctx.getImageData(0, 0, img_size, img_size).data;
            const t = new Float32Array(3 * img_size * img_size);
            for (let i = 0; i < img_size * img_size; i++) {
                t[i] = (d[i * 4] / 255 - input_mean[0]) / input_std[0];
                t[img_size * img_size + i] = (d[i * 4 + 1] / 255 - input_mean[1]) / input_std[1];
                t[2 * img_size * img_size + i] = (d[i * 4 + 2] / 255 - input_mean[2]) / input_std[2];
            }
            return t;
        }

        async function predict(src, forceSidebarOpen = true) { // Default to true for explicit captures/uploads
            if (!session) {
                showMessage('Model not ready', 'info');
                return;
            }
            loadingSpinner.style.display = 'flex'; // Show spinner

            try {
                const data = preprocess(src);
                const tensor = new ort.Tensor('float32', data, [1, 3, 224, 224]);
                const outMap = await session.run({ [MODEL_INPUT_NAME]: tensor });
                const logits = Array.from(outMap[Object.keys(outMap)[0]].data);
                const max = Math.max(...logits);
                const probs = logits.map(l => Math.exp(l - max));
                const sum = probs.reduce((a, b) => a + b, 0);
                const results = probs.map((p, i) => ({
                    class: MODEL_CONFIG.classes[i],
                    confidence: p / sum
                })).sort((a, b) => b.confidence - a.confidence);
                displayResults(results);
                showPredictionsSidebar(forceSidebarOpen); // Show sidebar with new results, respecting force flag
            } catch (e) {
                showMessage('Prediction failed: ' + e.message, 'error');
            } finally {
                loadingSpinner.style.display = 'none'; // Hide spinner
            }
        }

        function displayResults(res) {
            predictionsContent.innerHTML = ''; // Clear previous results
            res.slice(0, 5).forEach((r, i) => { // Added index 'i'
                const pct = (r.confidence * 100).toFixed(1);

                const predictionItem = document.createElement('div');
                predictionItem.className = 'prediction-item';

                const classNameSpan = document.createElement('span');
                classNameSpan.textContent = r.class;

                const predictionDetailsDiv = document.createElement('div');
                predictionDetailsDiv.className = 'prediction-details';

                const percentageSpan = document.createElement('span');
                percentageSpan.textContent = `${pct}%`;

                const confidenceBarDiv = document.createElement('div');
                confidenceBarDiv.className = 'confidence-bar';

                const confidenceFillDiv = document.createElement('div');
                confidenceFillDiv.className = 'confidence-fill';
                confidenceFillDiv.style.width = `${pct}%`;

                confidenceBarDiv.appendChild(confidenceFillDiv);
                predictionDetailsDiv.appendChild(percentageSpan);
                predictionDetailsDiv.appendChild(confidenceBarDiv);

                predictionItem.appendChild(classNameSpan);
                predictionItem.appendChild(predictionDetailsDiv);

                predictionsContent.appendChild(predictionItem);
            });

            // Update mini prediction display
            const topPrediction = res[0];
            if (topPrediction) {
                miniPredictionText.textContent = `${topPrediction.class} ${topPrediction.confidence * 100 > 0.1 ? (topPrediction.confidence * 100).toFixed(1) : '<0.1'}%`;
                livePredictionDisplay.textContent = `${topPrediction.class} (${(topPrediction.confidence * 100).toFixed(1)}%)`; // Removed "Live:"
            } else {
                miniPredictionText.textContent = 'No predictions.';
                livePredictionDisplay.textContent = 'No live prediction.';
            }
            updateClosedSidebarDisplay(); // Ensure mini button and live display visibility is managed
        }

        /* --- Webcam Logic --- */
        async function startWebcam() {
            if (webcamStream) { // Stop existing stream if any
                stopWebcam();
            }

            // Temporarily disable button to prevent multiple clicks while camera is starting
            takePhotoButton.disabled = true;

            const videoConstraints = {
                facingMode: isFrontCamera ? 'user' : 'environment'
            };

            try {
                webcamStream = await navigator.mediaDevices.getUserMedia({ video: videoConstraints });
                cameraFeed.srcObject = webcamStream;
                cameraFeed.style.display = 'block'; // Show live video
                imagePreview.style.display = 'none'; // Hide static image
                noCameraMessage.classList.add('hidden'); // Hide "no camera" message
                cameraToggleButton.classList.remove('hidden'); // Show toggle button
                applyZoom(MIN_ZOOM); // Reset zoom to 1x and apply
                zoomControls.classList.remove('hidden'); // Show zoom slider

                const cameraName = isFrontCamera ? 'Front Camera' : 'Back Camera';
                showMessage(`${cameraName} started! Continuous prediction active.`, 'success');

                isSidebarManuallyClosed = false; // Reset sidebar state when starting camera
                startContinuousPrediction(); // Start continuous prediction by default
                initialMessage.classList.add('hidden'); // Hide initial message when camera starts

            } catch (err) {
                console.error('Error accessing camera: ', err);
                cameraFeed.style.display = 'none';
                imagePreview.style.display = 'none';
                noCameraMessage.classList.remove('hidden'); // Show "no camera" message
                let errorMessage = 'Failed to start camera. ';
                if (err.name === 'NotAllowedError') {
                    errorMessage += 'Permission denied by user.';
                } else if (err.name === 'NotFoundError') {
                    errorMessage += 'No camera found.';
                } else if (err.name === 'OverconstrainedError') {
                    errorMessage += 'The requested camera (front/back) is not available or its constraints cannot be met. Try toggling.';
                } else {
                    errorMessage += 'Please ensure camera permissions are granted and no other app is using the camera.';
                }
                showMessage(errorMessage, 'error');
                cameraToggleButton.classList.add('hidden'); // Hide toggle if camera fails
                zoomControls.classList.add('hidden'); // Hide zoom slider
                stopContinuousPrediction(); // Ensure continuous prediction is stopped on error
                hidePredictionsSidebar(); // Ensure sidebar is hidden on camera error
                initialMessage.classList.remove('hidden'); // Show initial message on camera error
            } finally {
                takePhotoButton.disabled = false; // Always re-enable the button
            }
        }

        function stopWebcam() {
            stopContinuousPrediction(); // Stop continuous prediction
            if (webcamStream) {
                webcamStream.getTracks().forEach(track => track.stop());
                webcamStream = null;
            }
            cameraFeed.srcObject = null;
            cameraFeed.style.display = 'none'; // Hide video
            imagePreview.style.display = 'none'; // Hide any static image
            noCameraMessage.classList.remove('hidden'); // Show message
            noCameraMessage.textContent = 'Camera stopped. Press the Play button to start.'; // Update message
            cameraToggleButton.classList.add('hidden'); // Hide camera toggle
            zoomControls.classList.add('hidden'); // Hide zoom slider
            applyZoom(MIN_ZOOM); // Reset zoom
            hidePredictionsSidebar(); // Hide predictions and mini button
            isSidebarManuallyClosed = false; // Reset manual close state for next camera start

            takePhotoButton.innerHTML = '<i class="fas fa-play"></i>'; // Reset button to play
            takePhotoButton.classList.remove('stop-continuous'); // Ensure no red background
            takePhotoButton.disabled = false; // Ensure button is enabled
            showMessage('Camera stopped.', 'info');
            initialMessage.classList.remove('hidden'); // Show initial message
        }

        async function switchCamera() {
            isFrontCamera = !isFrontCamera; // Toggle camera state
            await startWebcam(); // Restart camera with new facing mode
        }

        function captureFrameForPrediction() {
            // Create a temporary canvas to draw the current video frame
            const v = cameraFeed;
            if (!v.videoWidth || !v.videoHeight) {
                showMessage('Video stream not ready for capture.', 'error');
                return;
            }
            const cvs = document.createElement('canvas');
            cvs.width = v.videoWidth;
            cvs.height = v.videoHeight;

            // Calculate source rectangle for zoomed-in portion
            const sx = (v.videoWidth - (v.videoWidth / currentZoom)) / 2;
            const sy = (v.videoHeight - (v.videoHeight / currentZoom)) / 2;
            const sWidth = v.videoWidth / currentZoom;
            const sHeight = v.videoHeight / currentZoom;

            // Draw the zoomed portion onto the canvas
            cvs.getContext('2d').drawImage(v, sx, sy, sWidth, sHeight, 0, 0, cvs.width, cvs.height);

            // Create a NEW Image object for this specific prediction
            const imgForPrediction = new Image();
            imgForPrediction.onload = () => {
                // Update the visible image preview
                imagePreview.src = imgForPrediction.src;
                imagePreview.style.display = 'block';
                cameraFeed.style.display = 'none';

                isSidebarManuallyClosed = false; // A new capture should open the sidebar
                predict(imgForPrediction, true); // Predict using the NEW Image object, force sidebar open
                showMessage('Photo captured! Displaying predictions.', 'info');
            };
            imgForPrediction.src = cvs.toDataURL('image/jpeg');
        }

        function startContinuousPrediction() {
            if (liveInterval) clearInterval(liveInterval); // Clear any old interval
            liveInterval = setInterval(() => {
                if (cameraFeed.readyState === cameraFeed.HAVE_ENOUGH_DATA) { // Ensure video is ready
                    const cvs = document.createElement('canvas');
                    cvs.width = cameraFeed.videoWidth;
                    cvs.height = cameraFeed.videoHeight;

                    // Calculate source rectangle for zoomed-in portion
                    const sx = (cameraFeed.videoWidth - (cameraFeed.videoWidth / currentZoom)) / 2;
                    const sy = (cameraFeed.videoHeight - (cameraFeed.videoHeight / currentZoom)) / 2;
                    const sWidth = cameraFeed.videoWidth / currentZoom;
                    const sHeight = cameraFeed.videoHeight / currentZoom;

                    // Draw the zoomed portion onto the canvas
                    cvs.getContext('2d').drawImage(cameraFeed, sx, sy, sWidth, sHeight, 0, 0, cvs.width, cvs.height);

                    const img = new Image();
                    img.onload = () => predict(img, false); // Pass false to indicate continuous mode prediction (don't force sidebar open)
                    img.src = cvs.toDataURL('image/jpeg');
                }
            }, 100); // Predict every 0.1 seconds for continuous mode
            continuousPredictionActive = true;
            cameraFeed.style.display = 'block'; // Ensure live video is shown when continuous starts
            imagePreview.style.display = 'none'; // Hide static image if resuming continuous
            takePhotoButton.innerHTML = '<i class="fas fa-pause"></i>'; // Change icon to pause continuous
            takePhotoButton.classList.add('stop-continuous'); // Style as 'stop' button
            showMessage('Continuous prediction started.', 'success');
            livePredictionDisplay.classList.remove('hidden'); // Show live prediction display
            initialMessage.classList.add('hidden'); // Hide initial message
        }

        function stopContinuousPrediction() {
            if (liveInterval) {
                clearInterval(liveInterval);
                liveInterval = null;
            }
            continuousPredictionActive = false;
            if (webcamStream) { // Only change button if camera is still active
                takePhotoButton.innerHTML = '<i class="fas fa-camera"></i>'; // Change icon to take photo
                takePhotoButton.classList.remove('stop-continuous'); // Reset button style
            }
            showMessage('Continuous prediction paused.', 'info');
            livePredictionDisplay.classList.add('hidden'); // Hide live prediction display
            updateClosedSidebarDisplay(); // Ensure mini button / initial message is correct after stopping continuous
        }

        /* --- UI Mode Switch --- */
        function setMode(mode) {
            uploadToggle.classList.remove('active');
            webcamToggle.classList.remove('active');
            uploadArea.style.display = 'none';
            webcamArea.style.display = 'none';
            imagePreview.style.display = 'none'; // Hide webcam preview image
            uploadedImagePreviewContainer.classList.add('hidden'); // Hide uploaded image preview
            hidePredictionsSidebar(); // Hide any existing predictions and mini button
            isSidebarManuallyClosed = false; // Reset manual close state on mode switch

            livePredictionDisplay.classList.add('hidden'); // Hide live prediction display
            initialMessage.classList.remove('hidden'); // Show initial message by default

            if (mode === 'upload') {
                uploadToggle.classList.add('active');
                uploadArea.style.display = 'flex'; // Use flex for centering content
                stopWebcam(); // Ensure webcam is stopped when switching to upload
                // The uploadedImagePreviewContainer will be shown by handleFile
            } else { // mode === 'webcam'
                webcamToggle.classList.add('active');
                webcamArea.style.display = 'block';
                // The webcam starts upon activating this mode via startWebcam() call
                startWebcam(); // This will handle showing camera feed and initial messages
            }
        }

        /* --- Event Wiring --- */
        window.addEventListener('DOMContentLoaded', () => {
            initModel(); // Initialize ONNX model

            // Mode toggles
            uploadToggle.addEventListener('click', () => setMode('upload'));
            webcamToggle.addEventListener('click', () => setMode('webcam'));

            // Upload functionality
            uploadArea.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', e => handleFile(e.target.files[0]));
            ['dragover', 'dragleave', 'drop'].forEach(evt => {
                uploadArea.addEventListener(evt, e => {
                    e.preventDefault();
                    uploadArea.classList.toggle('dragover', evt === 'dragover');
                    if (evt === 'drop' && e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]);
                });
            });

            // Webcam controls
            cameraToggleButton.addEventListener('click', switchCamera);
            takePhotoButton.addEventListener('click', () => {
                if (!webcamStream) { // State: Camera OFF (Play icon)
                    startWebcam(); // This starts continuous prediction
                } else { // State: Camera ON (Pause or Camera icon)
                    if (continuousPredictionActive) { // State: Continuous LIVE (Pause icon)
                        // User wants to pause continuous and capture a single frame
                        stopContinuousPrediction(); // This will change button to fa-camera
                        captureFrameForPrediction(); // Capture and predict
                    } else { // State: Continuous PAUSED/FROZEN (Camera icon)
                        // User wants to resume continuous live prediction
                        startContinuousPrediction(); // This will change button to fa-pause
                        hidePredictionsSidebar(); // Hide sidebar when returning to continuous
                    }
                }
            });


            // Zoom slider
            zoomSlider.addEventListener('input', (event) => {
                const zoomLevel = parseFloat(event.target.value);
                applyZoom(zoomLevel);
            });

            // Pinch-to-zoom logic (only for mobile devices)
            if (isMobileDevice()) {
                videoContainer.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 2) {
                        initialPinchDistance = Math.hypot(
                            e.touches[0].clientX - e.touches[1].clientX,
                            e.touches[0].clientY - e.touches[1].clientY
                        );
                        lastZoom = currentZoom; // Store current zoom to base relative changes
                        e.preventDefault(); // Prevent default browser gestures like page zoom
                    }
                });

                videoContainer.addEventListener('touchmove', (e) => {
                    if (e.touches.length === 2 && initialPinchDistance > 0) {
                        const currentPinchDistance = Math.hypot(
                            e.touches[0].clientX - e.touches[1].clientX,
                            e.touches[0].clientY - e.touches[1].clientY
                        );

                        const scaleFactor = currentPinchDistance / initialPinchDistance;
                        let newZoom = lastZoom * scaleFactor;

                        applyZoom(newZoom);
                        e.preventDefault(); // Prevent default browser gestures
                    }
                });

                videoContainer.addEventListener('touchend', () => {
                    initialPinchDistance = -1; // Reset pinch state
                });
                videoContainer.addEventListener('touchcancel', () => { // Handle cases where touch is interrupted
                    initialPinchDistance = -1;
                });
            }

            // Close predictions sidebar
            closePredictionsButton.addEventListener('click', hidePredictionsSidebar);
            // Open predictions sidebar from mini button
            openPredictionsButton.addEventListener('click', () => {
                isSidebarManuallyClosed = false; // Reset manual close flag
                showPredictionsSidebar(true); // Force sidebar open
            });


            // Default mode on load
            setMode('upload');
        });

        /* --- File Handling for Upload Mode --- */
        function handleFile(file) {
            if (!file.type.startsWith('image/')) {
                showMessage('Please choose an image file (e.g., JPG, PNG).', 'error');
                return;
            }
            const reader = new FileReader();
            reader.onload = e => {
                const img = new Image();
                img.onload = () => {
                    uploadedImageDisplay.src = e.target.result; // Set new image
                    uploadedImagePreviewContainer.classList.remove('hidden'); // Show container

                    // Ensure no other preview elements are showing if coming from webcam mode
                    imagePreview.style.display = 'none';
                    cameraFeed.style.display = 'none';

                    isSidebarManuallyClosed = false; // A new upload should open the sidebar
                    predict(img, true); // Run prediction, force sidebar open
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
    </script>
</body>
</html>
